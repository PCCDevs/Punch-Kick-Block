<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simultaneous HUSTLE</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        :root {
            --p1-color: #f87171; /* Red 400 */
            --p2-color: #34d399; /* Emerald 400 */
            --bg-dark: #1f2937;
        }
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: var(--bg-dark);
            color: #ffffff;
            user-select: none; 
        }
        .text-neon-red { color: var(--p1-color); }
        .text-neon-green { color: var(--p2-color); }
        .game-screen {
            min-height: 80vh;
            background: linear-gradient(145deg, #111827, #2d3748);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .hp-bar-fill {
            transition: width 0.5s ease-out;
            border-radius: 9999px;
            height: 100%;
        }
        .move-button {
            border: 3px solid;
            transition: all 0.1s;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.7);
            /* Removed fixed height: 4rem; to use Tailwind h-14 */
        }
        .move-button:hover:not(.selected) {
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }
        .move-button.selected {
            transform: scale(1.05);
            filter: brightness(1.2);
            box-shadow: 0 0 20px 5px rgba(255, 255, 255, 0.8);
        }
        .p1-selected { border-color: var(--p1-color) !important; background-color: rgba(248, 113, 113, 0.3) !important; }
        .p2-selected { border-color: var(--p2-color) !important; background-color: rgba(52, 211, 153, 0.3) !important; }

        /* Commit State Styles */
        .committed .player-move-hint,
        .committed .move-button {
            display: none !important;
        }
        .player-controls-inner {
            display: block;
        }
        .committed .player-controls-inner {
            display: none;
        }
        
        /* Skip/Stun State Styles - Same as committed, but specific styling for the message */
        .skipping .player-controls-inner {
            display: none;
        }
        .committed-message {
            font-size: 1.2rem;
            color: #ccc;
            animation: pulse-commit 1s infinite alternate;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            padding: 1rem;
        }
        .skipping-message {
            color: #fca5a5; /* Reddish tone for stun */
        }
        @keyframes pulse-commit {
            from { opacity: 0.7; }
            to { opacity: 1; }
        }
        
        /* Character icon styles */
        .character-icon {
            font-size: 3rem;
            transition: left 0.3s ease-in-out, transform 0.1s ease-in-out, top 0.3s ease-in-out, filter 0.1s;
            position: absolute;
            bottom: 10px;
        }
        /* Airborne position lift */
        .character-icon.airborne {
            top: 10px !important; 
        }
        /* Icon flash for confirmation */
        .character-icon.flash {
            filter: drop-shadow(0 0 10px white) brightness(1.5);
        }
        
    </style>
    <!-- Configure Tailwind for Inter font -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
</head>
<body class="p-4 flex items-center justify-center min-h-screen">

    <div id="game-container" class="w-full max-w-4xl p-6 rounded-xl game-screen shadow-2xl">
        
        <!-- Header & Health Bars -->
        <div class="flex justify-between items-center mb-6">
            <div class="w-1/2 pr-2">
                <h2 class="text-sm md:text-xl text-neon-red mb-1">P1 (Red) - <span id="p1-meter" class="text-xs">Meter: 0</span></h2>
                <div class="h-6 border-4 border-neon-red bg-gray-600 rounded-full overflow-hidden">
                    <div id="p1-hp" class="hp-bar-fill bg-red-500" style="width: 100%;"></div>
                </div>
            </div>
            <div class="w-1/2 pl-2 text-right">
                <h2 class="text-sm md:text-xl text-neon-green mb-1">P2 (Green) - <span id="p2-meter" class="text-xs">Meter: 0</span></h2>
                <div class="h-6 border-4 border-neon-green bg-gray-600 rounded-full overflow-hidden">
                    <div id="p2-hp" class="hp-bar-fill bg-emerald-500" style="width: 100%;"></div>
                </div>
            </div>
        </div>

        <!-- Arena and Position Tracker -->
        <div id="arena" class="relative h-28 bg-gray-900 border-4 border-gray-700 rounded-lg mb-6 flex items-center justify-center">
            <!-- Icons: ðŸ‘Š (Punch) for P1, ðŸ¦µ (Kick) for P2 -->
            <div id="p1-char" class="character-icon text-neon-red" style="left: 10%;">ðŸ‘Š</div>
            <div id="p2-char" class="character-icon text-neon-green" style="left: 80%; transform: scaleX(-1);">ðŸ¦µ</div>
            <div id="distance-indicator" class="text-xl text-yellow-400 absolute top-0 mt-2">Distance: 7</div>
        </div>

        <!-- Result/Status Message - Increased height (h-20) and padding (p-3) for better fit -->
        <div id="status-message" class="h-20 flex items-center justify-center text-center text-lg md:text-xl mb-6 text-yellow-300 bg-gray-800 rounded p-3 overflow-hidden">
            SELECT YOUR MOVES & THE TURN WILL EXECUTE!
        </div>
        
        <!-- Move Selection Area -->
        <div id="move-selection" class="space-y-6">

            <!-- P1 Controls (Red) -->
            <div id="p1-controls" class="p-4 bg-gray-800 rounded-lg border-2 border-neon-red player-controls">
                <h3 class="text-lg mb-3 text-neon-red text-center w-full">Player 1 (Red)</h3>
                <div class="player-controls-inner">
                    <!-- Row 1: Attack Moves (6 columns) - Added h-14 to buttons -->
                    <div class="grid grid-cols-6 gap-2 mb-2">
                        <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-900 hover:bg-red-700" data-player="p1" data-move="PUNCH">Punch (P:1/0)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-900 hover:bg-red-700" data-player="p1" data-move="UPPERCUT">Upper (P:2/5)</button> 
                        <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-900 hover:bg-red-700" data-player="p1" data-move="KICK">Kick (P:3/10)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-700 hover:bg-red-500" data-player="p1" data-move="THROW">Throw (P:3/10)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-900 hover:bg-red-700" data-player="p1" data-move="SHOOT">Shoot (P:2/5)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-700 hover:bg-red-500" data-player="p1" data-move="AERIAL_KICK">Air Kick (P:3/15)</button>
                    </div>
                    <!-- Row 2: Defensive/Positional Moves (5 columns) - Added h-14 to buttons -->
                    <div class="grid grid-cols-5 gap-2">
                        <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-900 hover:bg-red-700" data-player="p1" data-move="BLOCK">Block (0M)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-900 hover:bg-red-700" data-player="p1" data-move="PARRY">Parry (P:0/5)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-700 hover:bg-red-500" data-player="p1" data-move="FEINT">Feint (vs P0/1)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-900 hover:bg-red-700" data-player="p1" data-move="JUMP">Jump (0M)</button> 
                        <div class="grid grid-cols-2 gap-2 col-span-1">
                            <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-900 hover:bg-red-700" data-player="p1" data-move="DASH_FWD">Fwd</button>
                            <button class="move-button h-14 p-2 text-xs border-neon-red bg-red-900 hover:bg-red-700" data-player="p1" data-move="DASH_BACK">Back</button>
                        </div>
                    </div>
                    <div id="p1-hint" class="player-move-hint text-xs mt-2 text-right text-red-300">Move Selected!</div>
                </div>
                <div id="p1-status" class="committed-message hidden"></div>
            </div>

            <!-- P2 Controls (Green) -->
            <div id="p2-controls" class="p-4 bg-gray-800 rounded-lg border-2 border-neon-green player-controls">
                <h3 class="text-lg mb-3 text-neon-green text-center w-full">Player 2 (Green)</h3>
                <div class="player-controls-inner">
                    <!-- Row 1: Attack Moves (6 columns) - Added h-14 to buttons -->
                    <div class="grid grid-cols-6 gap-2 mb-2">
                        <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-900 hover:bg-emerald-700" data-player="p2" data-move="PUNCH">Punch (P:1/0)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-900 hover:bg-emerald-700" data-player="p2" data-move="UPPERCUT">Upper (P:2/5)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-900 hover:bg-emerald-700" data-player="p2" data-move="KICK">Kick (P:3/10)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-700 hover:bg-emerald-500" data-player="p2" data-move="THROW">Throw (P:3/10)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-900 hover:bg-emerald-700" data-player="p2" data-move="SHOOT">Shoot (P:2/5)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-700 hover:bg-emerald-500" data-player="p2" data-move="AERIAL_KICK">Air Kick (P:3/15)</button>
                    </div>
                    <!-- Row 2: Defensive/Positional Moves (5 columns) - Added h-14 to buttons -->
                    <div class="grid grid-cols-5 gap-2">
                        <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-900 hover:bg-emerald-700" data-player="p2" data-move="BLOCK">Block (0M)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-900 hover:bg-emerald-700" data-player="p2" data-move="PARRY">Parry (P:0/5)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-700 hover:bg-emerald-500" data-player="p2" data-move="FEINT">Feint (vs P0/1)</button>
                        <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-900 hover:bg-emerald-700" data-player="p2" data-move="JUMP">Jump (0M)</button>
                        <div class="grid grid-cols-2 gap-2 col-span-1">
                            <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-900 hover:bg-emerald-700" data-player="p2" data-move="DASH_FWD">Fwd</button>
                            <button class="move-button h-14 p-2 text-xs border-neon-green bg-emerald-900 hover:bg-emerald-700" data-player="p2" data-move="DASH_BACK">Back</button>
                        </div>
                    </div>
                    <div id="p2-hint" class="player-move-hint text-xs mt-2 text-right text-emerald-300">Move Selected!</div>
                </div>
                <div id="p2-status" class="committed-message hidden"></div>
            </div>
            
            <!-- Execute Turn Button (Status Display Only) -->
            <div class="text-center pt-4">
                <button id="execute-button" class="bg-gray-700 text-gray-500 font-bold py-3 px-8 rounded-full text-lg md:text-2xl shadow-xl transition-colors" disabled>
                    WAITING FOR BOTH PLAYERS
                </button>
            </div>
        </div>

        <!-- Game Over Modal -->
        <div id="game-over-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-8 rounded-lg shadow-2xl text-center border-4 border-yellow-500">
                <h2 id="winner-message" class="text-4xl mb-4 text-yellow-400 font-bold"></h2>
                <p class="text-xl mb-6">Game Over!</p>
                <button id="restart-button" class="bg-yellow-500 text-gray-900 font-bold py-3 px-6 rounded text-lg hover:bg-yellow-300">
                    Play Again
                </button>
            </div>
        </div>
    </div>

    <script>
        // Game State Variables
        let P1 = { hp: 100, meter: 0, move: null, pos: 1, isAirborne: false, isCommitted: false, isSkippingTurn: 0 };
        let P2 = { hp: 100, meter: 0, move: null, pos: 9, isAirborne: false, isCommitted: false, isSkippingTurn: 0 };
        const MAX_METER = 50;
        // Allows attacks to hit when distance is 4 (e.g., pos 1 and pos 5) - range 2 on the grid
        const MIN_DISTANCE_TO_HIT = 5; 
        const DASH_DISTANCE = 2; // Dash distance set to 2
        const KNOCKBACK_DISTANCE = 2; // New constant for THROW knockback distance

        // MOVESET definition: 
        const MOVESET = {
            PUNCH: { cost: 0, damage: 10, priority: 1, onHitAdvantage: 5, onWhiffPenalty: -5 }, 
            UPPERCUT: { cost: 5, damage: 10, antiAirDamage: 20, priority: 2, onHitAdvantage: 10, onWhiffPenalty: -10 }, 
            SHOOT: { cost: 5, damage: 10, priority: 2, onHitAdvantage: 5, onWhiffPenalty: 0 }, 
            KICK: { cost: 10, damage: 25, priority: 3, onHitAdvantage: 10, onWhiffPenalty: -15 }, 
            THROW: { cost: 10, damage: 15, priority: 3, onHitAdvantage: 10, onWhiffPenalty: -15 },
            AERIAL_KICK: { cost: 15, damage: 30, maxDamage: 90, priority: 3, onHitAdvantage: 15, onWhiffPenalty: -15 }, 
            FEINT: { cost: 5, damage: 0, priority: 0, onHitAdvantage: 10, onWhiffPenalty: -5 }, 
            
            BLOCK: { cost: 0, damage: 0, priority: 0, onHitAdvantage: 5, onWhiffPenalty: 0 },
            SKIPPED: { cost: 0, damage: 0, priority: 0, onHitAdvantage: 0, onWhiffPenalty: 0 }, // For Skip Turn state
            DASH_FWD: { cost: 0, damage: 0, priority: 0, onHitAdvantage: 5, onWhiffPenalty: 0 }, 
            DASH_BACK: { cost: 0, damage: 0, priority: 0, onHitAdvantage: 5, onWhiffPenalty: 0 }, 
            JUMP: { cost: 0, damage: 0, priority: 0, onHitAdvantage: 5, onWhiffPenalty: 0 }, 
            PARRY: { cost: 5, damage: 0, priority: 0, onHitAdvantage: 15, onWhiffPenalty: -5, isParry: true }, 
        };
        
        const ATTACK_MOVES = ['PUNCH', 'UPPERCUT', 'KICK', 'THROW', 'SHOOT', 'AERIAL_KICK'];

        const $ = selector => document.querySelector(selector);
        const $$ = selector => document.querySelectorAll(selector);

        // DOM Elements
        const p1HpBar = $('#p1-hp');
        const p2HpBar = $('#p2-hp');
        const p1Meter = $('#p1-meter');
        const p2Meter = $('#p2-meter');
        const p1Char = $('#p1-char');
        const p2Char = $('#p2-char');
        const statusMessage = $('#status-message');
        const executeButton = $('#execute-button');
        const gameOverModal = $('#game-over-modal');
        const winnerMessage = $('#winner-message');
        const distanceIndicator = $('#distance-indicator');
        const p1Controls = $('#p1-controls');
        const p2Controls = $('#p2-controls');
        const p1StatusMessage = $('#p1-status');
        const p2StatusMessage = $('#p2-status');


        // Utility to update the UI elements
        function updateUI() {
            // HP bars update (using Math.floor to ensure full integer width for display)
            p1HpBar.style.width = `${Math.max(0, P1.hp)}%`;
            p2HpBar.style.width = `${Math.max(0, P2.hp)}%`;

            // Meter update
            p1Meter.textContent = `Meter: ${P1.meter}/${MAX_METER}`;
            p2Meter.textContent = `Meter: ${P2.meter}/${MAX_METER}`;

            // Update character positions and airborne status
            p1Char.style.left = `${P1.pos * 10}%`;
            p2Char.style.left = `${P2.pos * 10}%`;
            
            // Apply airborne class if jump was executed last turn
            p1Char.classList.toggle('airborne', P1.isAirborne); 
            p2Char.classList.toggle('airborne', P2.isAirborne);

            const distance = Math.abs(P2.pos - P1.pos);
            distanceIndicator.textContent = `Distance: ${distance}`;
            distanceIndicator.classList.toggle('text-red-400', distance < MIN_DISTANCE_TO_HIT);
            distanceIndicator.classList.toggle('text-yellow-400', distance >= MIN_DISTANCE_TO_HIT);

            // Check for skipping status
            const isP1Skipping = P1.isSkippingTurn > 0;
            const isP2Skipping = P2.isSkippingTurn > 0;
            
            // Player Ready Status (A player is ready if they committed a move OR are forced to skip)
            const p1Ready = P1.isCommitted || isP1Skipping;
            const p2Ready = P2.isCommitted || isP2Skipping;

            // --- UI VISUALS ---

            // P1 Status
            p1Controls.classList.toggle('committed', P1.isCommitted && !isP1Skipping);
            p1StatusMessage.classList.toggle('hidden', !P1.isCommitted && !isP1Skipping);
            p1StatusMessage.classList.remove('skipping-message');

            if (isP1Skipping) {
                p1StatusMessage.textContent = 'STUNNED! SKIPPING TURN.';
                p1StatusMessage.classList.add('skipping-message');
                p1StatusMessage.classList.remove('hidden');
            } else if (P1.isCommitted) {
                p1StatusMessage.textContent = 'MOVE COMMITTED';
            }


            // P2 Status
            p2Controls.classList.toggle('committed', P2.isCommitted && !isP2Skipping);
            p2StatusMessage.classList.toggle('hidden', !P2.isCommitted && !isP2Skipping);
            p2StatusMessage.classList.remove('skipping-message');

            if (isP2Skipping) {
                p2StatusMessage.textContent = 'STUNNED! SKIPPING TURN.';
                p2StatusMessage.classList.add('skipping-message');
                p2StatusMessage.classList.remove('hidden');
            } else if (P2.isCommitted) {
                p2StatusMessage.textContent = 'MOVE COMMITTED';
            }

            // Check if game over
            if (isGameOver()) {
                endGame();
                return;
            }

            // --- Auto-Execute Logic ---
            if (p1Ready && p2Ready) {
                executeButton.setAttribute('disabled', 'true');
                executeButton.classList.add('bg-yellow-500', 'animate-pulse', 'text-gray-900');
                executeButton.classList.remove('bg-gray-700', 'text-gray-500');
                executeButton.textContent = 'EXECUTING TURN...';
                statusMessage.textContent = 'Executing turn...';
                
                setTimeout(() => {
                    processTurn();
                }, 400); 
                
            } else if (p1Ready || p2Ready) {
                executeButton.classList.remove('bg-yellow-500', 'animate-pulse', 'text-gray-900');
                executeButton.classList.add('bg-gray-700', 'text-gray-500');
                executeButton.textContent = 'WAITING FOR OTHER PLAYER...';
                
                let waitingFor = '';
                if (!p1Ready) waitingFor = 'P1';
                if (!p2Ready) waitingFor = waitingFor ? `${waitingFor} & P2` : 'P2';
                
                statusMessage.textContent = `Waiting for ${waitingFor} to commit move...`;

            } else {
                 executeButton.textContent = 'WAITING FOR BOTH PLAYERS';
                 statusMessage.textContent = 'SELECT YOUR MOVES & THE TURN WILL EXECUTE!';
            }
            // --- End Auto-Execute Logic ---
        }

        // Check if a move is a successful hit based on distance
        function isCloseEnough() {
            return Math.abs(P2.pos - P1.pos) < MIN_DISTANCE_TO_HIT;
        }

        /**
         * Helper function to apply damage, meter gain, and compose a result message.
         */
        function resolveHit(winnerState, winnerName, loserState, damage, meterGain, msg) {
            loserState.hp = Math.max(0, loserState.hp - damage);
            winnerState.meter = Math.min(MAX_METER, winnerState.meter + meterGain);
            return `${winnerName}: ${msg}`;
        }
        
        /**
         * Helper function to apply the penalty for a whiffed or blocked move.
         */
        function applyPenalty(state, name, move, penalty, reason) {
            state.meter = Math.max(0, state.meter + penalty); // penalty is negative
            // Ensure penalty message is clear
            if (penalty < 0) {
                 return `${name}'s ${move} fails! ${reason}. Meter penalized by ${Math.abs(penalty)}.`;
            }
            return `${name}'s ${move} executes. ${reason}. ${penalty > 0 ? `Meter +${penalty}.` : ''}`;
        }
        
        /**
         * Applies knockback to the defender after a successful THROW.
         */
        function applyKnockback(attacker, defender) {
            const isP1Attacker = attacker === P1;
            
            if (isP1Attacker) {
                // P1 attacks P2: P2 moves right (increase position)
                defender.pos = Math.min(defender.pos + KNOCKBACK_DISTANCE, 9);
                // Ensure P1 doesn't move past P2
                attacker.pos = Math.min(attacker.pos, defender.pos - 1);
            } else {
                // P2 attacks P1: P1 moves left (decrease position)
                defender.pos = Math.max(defender.pos - KNOCKBACK_DISTANCE, 1);
                // Ensure P2 doesn't move past P1
                attacker.pos = Math.max(attacker.pos, defender.pos + 1);
            }
        }


        /**
         * Main move resolution function based on the faster move.
         * NOTE: Anti-Air JUMP counters (UPPERCUT/AERIAL_KICK vs JUMP) are handled in processTurn before this function is called.
         */
        function resolveSequentialInteraction(attacker, attackerName, defender, defenderName) {
            const attMove = attacker.move;
            const defMove = defender.move;
            const attData = MOVESET[attMove];
            
            const groundAttacks = ['PUNCH', 'UPPERCUT', 'KICK', 'THROW'];
            const rangedAttack = 'SHOOT';
            const defMoveIsAttack = ATTACK_MOVES.includes(defMove);
            
            let resultMessage = '';
            let moveResolved = false;

            // --- A. Resolve Attacker's Action ---
            
            // 0.1 Attacker (FEINT) vs Defender (P:0 or P:1 Move) - Feint Success
            if (attMove === 'FEINT' && MOVESET[defMove].priority <= 1 && !moveResolved) {
                // 1. Feinter gains meter (onHitAdvantage: 10)
                attacker.meter = Math.min(MAX_METER, attacker.meter + attData.onHitAdvantage);
                
                // 2. Opponent loses 5 meter, their move is nullified (0 damage)
                defender.meter = Math.max(0, defender.meter - 5); 
                
                // 3. Craft message
                resultMessage = `${attackerName} FEINTS, causing ${defenderName}'s ${defMove} (P:${MOVESET[defMove].priority}) to fail (Nullified)! ${defenderName} loses 5 Meter.`;
                moveResolved = true;
            }

            // 0.2 Attacker (AERIAL_KICK) vs Defender (UPPERCUT/THROW) - AERIAL KICK Countered
            else if (attMove === 'AERIAL_KICK' && (defMove === 'THROW' || defMove === 'UPPERCUT') && isCloseEnough() && !moveResolved) {
                // Apply penalty to the AERIAL_KICK user for being countered and STUN them
                attacker.isSkippingTurn = 1; // STUN!
                resultMessage = applyPenalty(attacker, attackerName, attMove, attData.onWhiffPenalty, `COUNTERED by ${defenderName}'s ${defMove}! ${attackerName} is STUNNED next turn.`);
                moveResolved = true;
            }

            // 0.4 Attacker (PARRY) vs Defender (non-Attack or too far) - Parry Fail
            else if (attMove === 'PARRY' && !moveResolved) {
                // If defender's move is not an attack, or they are too far for any close attack
                if (!defMoveIsAttack || !isCloseEnough()) {
                    attacker.isSkippingTurn = 1; // Attacker is stunned next turn
                    attacker.meter = Math.max(0, attacker.meter + MOVESET.PARRY.onWhiffPenalty);
                    moveResolved = true;
                    return `${attackerName}'s PARRY misses! ${defenderName} used a non-attacking move or was too far. ${attackerName} loses next turn.`;
                }
            }
            
            // 1. Attacker (Attack) vs Defender (PARRY) - Parry Success
            if (defMove === 'PARRY' && ATTACK_MOVES.includes(attMove) && isCloseEnough() && !moveResolved) {
                attacker.isSkippingTurn = 1; // Attacker is stunned next turn
                defender.meter = Math.min(MAX_METER, defender.meter + MOVESET.PARRY.onHitAdvantage);
                moveResolved = true;
                return `${defenderName} successfully PARRY's ${attackerName}'s ${attMove}! ${attackerName} loses next turn.`;
            }

            // 2. Attacker (Attack) vs Defender (BLOCK)
            else if (defMove === 'BLOCK' && attMove !== 'THROW' && attMove !== 'JUMP' && !moveResolved) {
                // Only resolve BLOCK if close enough for ground attacks, or if SHOOT
                if (groundAttacks.includes(attMove) && !isCloseEnough()) {
                    // Treat as whiff/whiff penalty if it was a ground attack that was too far to be blocked
                    // This is covered by case 6 (Whiff due to distance) below, so skip here.
                } else {
                    let chipDamage = 0;
                    
                    // Block takes reduced damage
                    if (attMove === 'KICK' || attMove === 'AERIAL_KICK') { // AERIAL_KICK also has chip if blocked
                        chipDamage = attData.damage / 4; 
                    } else if (attMove === 'SHOOT') {
                        chipDamage = attData.damage / 2; 
                    } else if (attMove === 'PUNCH' || attMove === 'UPPERCUT') { 
                        chipDamage = 2; 
                    }

                    if (chipDamage > 0) {
                        defender.hp = Math.max(0, defender.hp - chipDamage);
                        const roundedDamage = Math.round(chipDamage * 10) / 10;
                        resultMessage = `${attackerName}'s ${attMove} is BLOCKED! ${defenderName} takes ${roundedDamage} chip damage.`;
                    } else {
                        resultMessage = `${attackerName}'s ${attMove} is perfectly BLOCKED!`;
                    }
                    
                    attacker.meter = Math.max(0, attacker.meter + attData.onWhiffPenalty); 
                    defender.meter = Math.min(MAX_METER, defender.meter + MOVESET.BLOCK.onHitAdvantage); 
                    moveResolved = true;
                }
            } 
            
            // 3. Attacker (THROW) vs BLOCK 
            else if (attMove === 'THROW' && defMove === 'BLOCK' && isCloseEnough() && !moveResolved) {
                resultMessage = resolveHit(attacker, attackerName, defender, attData.damage, attData.onHitAdvantage, `Throw GRABS ${defenderName} through their Block!`);
                applyKnockback(attacker, defender); // Apply knockback
                resultMessage += ` (Knockback ${KNOCKBACK_DISTANCE} applied)`;
                moveResolved = true;
            }
            // 3b. THROW whiffed due to distance
            else if (attMove === 'THROW' && !isCloseEnough() && !moveResolved) {
                 resultMessage = applyPenalty(attacker, attackerName, attMove, attData.onWhiffPenalty, `Too far! Throw whiffs due to distance`);
                 moveResolved = true;
            }
            
            // 4. Ground Attack vs JUMP (already handled in processTurn now - this is only for non-counterable ground attacks whiffing a fast JUMP)
            // But, if the anti-air counter in processTurn failed (e.g., due to distance), we treat the ground attack as a whiff here.
            
            // 5. Attacker (SHOOT) vs JUMP 
            else if (attMove === rangedAttack && defMove === 'JUMP' && !moveResolved) {
                 resultMessage = applyPenalty(attacker, attackerName, attMove, attData.onWhiffPenalty, `${defenderName} JUMPS over the shot! (Evasion)`);
                 moveResolved = true;
            }
            
            // 6. Attacker Whiffs (Too far) - Only applies to ground attacks (PUNCH, UPPERCUT, KICK, THROW, AERIAL_KICK)
            else if (['PUNCH', 'UPPERCUT', 'KICK', 'THROW', 'AERIAL_KICK'].includes(attMove) && !isCloseEnough() && !moveResolved) {
                // AERIAL KICK WHIFF -> STUN
                 if (attMove === 'AERIAL_KICK') {
                     attacker.isSkippingTurn = 1; // STUN!
                     resultMessage = applyPenalty(attacker, attackerName, attMove, attData.onWhiffPenalty, `Too far! ${attackerName} is STUNNED next turn.`);
                 } else {
                     resultMessage = applyPenalty(attacker, attackerName, attMove, attData.onWhiffPenalty, `Too far! Attack whiffs due to distance`);
                 }
                moveResolved = true;
            }

            // 7. Attacker Lands A Clean Hit (Attacker's move is faster and hits the commitment of the slower move)
            else if (ATTACK_MOVES.includes(attMove) && !moveResolved) { 
                // Normal hit damage for other attacks
                const damage = attData.damage;
                resultMessage = resolveHit(attacker, attackerName, defender, damage, attData.onHitAdvantage, `${attMove} INTERRUPTS ${defenderName}'s ${defMove}!`);
                
                if (attMove === 'THROW') {
                    applyKnockback(attacker, defender);
                    resultMessage += ` (Knockback ${KNOCKBACK_DISTANCE} applied)`;
                }

                moveResolved = true;
            }
            
            // 8. Attacker Executes Non-Offensive Move (DASH_FWD/BACK, BLOCK, JUMP, PARRY, FEINT)
            if (!moveResolved) {
                 // For BLOCK/DASH/JUMP/FEINT, just execute the action/gain meter.
                 resultMessage = applyPenalty(attacker, attackerName, attMove, attData.onHitAdvantage, `${attMove} executes.`);
                 moveResolved = true;
            }
            
            return resultMessage;
        }

        // Core turn processing logic
        function processTurn() {
            // Capture the moves selected by the users before any modifications
            const p1SelectedMove = P1.move;
            const p2SelectedMove = P2.move;

            let message = `<span class="text-neon-red">${p1SelectedMove}</span> vs <span class="text-neon-green">${p2SelectedMove}</span>: `;
            
            // --- 0. Check for skip turn and apply skip logic ---
            const p1IsSkipping = P1.isSkippingTurn > 0;
            const p2IsSkipping = P2.isSkippingTurn > 0;

            if (p1IsSkipping) {
                P1.isSkippingTurn--;
                P1.move = 'SKIPPED';
            }
            if (p2IsSkipping) {
                P2.isSkippingTurn--;
                P2.move = 'SKIPPED';
            }

            if (P1.move === 'SKIPPED' && P2.move === 'SKIPPED') {
                 statusMessage.innerHTML = 'Both players skipped turn due to previous stun/penalty.';
                 setTimeout(resetTurnState, 1800);
                 return;
            }

            let p1Move = P1.move;
            let p2Move = P2.move;

            // FIX: Safely determine move data.
            let p1Data = MOVESET[p1Move];
            let p2Data = MOVESET[p2Move];
            
            if (p1Move === 'SKIPPED') { 
                message += `<span class="text-neon-red">P1 is stunned and SKIPS turn.</span>. `;
            }
            if (p2Move === 'SKIPPED') { 
                message += `<span class="text-neon-green">P2 is stunned and SKIPS turn.</span>. `;
            }


            // --- 1. Meter Check & Cost Application (only if not skipped) ---
            if (p1Move !== 'SKIPPED') {
                if (P1.meter < p1Data.cost) {
                    P1.move = 'PUNCH';
                    p1Data = MOVESET.PUNCH; 
                    message += `<span class="text-red-400">P1 failed to pay ${p1SelectedMove} cost, defaulted to PUNCH (P:1)</span>. `;
                } else {
                    P1.meter -= p1Data.cost;
                }
            }

            if (p2Move !== 'SKIPPED') {
                if (P2.meter < p2Data.cost) {
                    P2.move = 'PUNCH';
                    p2Data = MOVESET.PUNCH;
                    message += `<span class="text-emerald-400">P2 failed to pay ${p2SelectedMove} cost, defaulted to PUNCH (P:1)</span>. `;
                } else {
                    P2.meter -= p2Data.cost;
                }
            }
            
            // Final move data after potential PUNCH default
            const p1FinalData = MOVESET[P1.move];
            const p2FinalData = MOVESET[P2.move];
            
            // Ensure priority variables reflect the final state
            let p1Priority = p1FinalData.priority;
            let p2Priority = p2FinalData.priority;


            // --- 2. Positional and Airborne State Setup (P0 moves like DASH and JUMP execute here) ---
            
            // Reset airborne status BEFORE applying new JUMP move
            P1.isAirborne = false; 
            P2.isAirborne = false;

            // Apply JUMP status for the duration of the turn interaction
            if (P1.move === 'JUMP') { 
                P1.isAirborne = true;
            }
            if (P2.move === 'JUMP') { 
                P2.isAirborne = true;
            }

            // Apply movement (DASH moves are P0 and use DASH_DISTANCE = 2)
            if (P1.move === 'DASH_FWD') { 
                // P1 moves right (towards P2)
                P1.pos = Math.min(P1.pos + DASH_DISTANCE, P2.pos - 1); 
            }
            if (P1.move === 'DASH_BACK') { 
                // P1 moves left (away from P2). Min position is 1 (10% left).
                P1.pos = Math.max(P1.pos - DASH_DISTANCE, 1); 
            }

            if (P2.move === 'DASH_FWD') { 
                // P2 moves left (towards P1)
                P2.pos = Math.max(P2.pos - DASH_DISTANCE, P1.pos + 1); 
            }
            if (P2.move === 'DASH_BACK') { 
                // P2 moves right (away from P1). Max position is 9 (90% left).
                P2.pos = Math.min(P2.pos + DASH_DISTANCE, 9); 
            }

            // Ensure fighters don't cross over
            if (P1.pos >= P2.pos) {
                const midpoint = Math.floor((P1.pos + P2.pos) / 2);
                P1.pos = midpoint;
                P2.pos = midpoint + 1;
            }
            
            // --- 3. Sequential Conflict Resolution (Priority Based) ---
            
            if (P1.move === 'SKIPPED' || P2.move === 'SKIPPED') {
                // Handle interaction where one player skipped
                if (P1.move === 'SKIPPED' && P2.move !== 'SKIPPED') {
                    // P2 acts against P1's skip (which acts like a permanent block/defense)
                    message += resolveSequentialInteraction(P2, 'P2', P1, 'P1');
                } else if (P2.move === 'SKIPPED' && P1.move !== 'SKIPPED') {
                    // P1 acts against P2's skip
                    message += resolveSequentialInteraction(P1, 'P1', P2, 'P2');
                }
            }
            else if (p1Priority !== p2Priority) {
                
                let activePlayer = (p1Priority < p2Priority) ? P1 : P2;
                let passivePlayer = (p1Priority < p2Priority) ? P2 : P1;
                let activeName = (p1Priority < p2Priority) ? 'P1' : 'P2';
                let passiveName = (p1Priority < p2Priority) ? 'P2' : 'P1';
                let passiveData = (p1Priority < p2Priority) ? p2FinalData : p1FinalData;

                let att, def, attName, defName;
                let overrideResult = '';

                // --- ANTI-AIR COUNTER OVERRIDE ---
                // If the faster move (activePlayer) is JUMP (P:0) and the slower move (passivePlayer) is an Anti-Air
                if (activePlayer.move === 'JUMP' && passivePlayer.isAirborne === false) {
                    if (passivePlayer.move === 'UPPERCUT' && isCloseEnough()) {
                        const damage = MOVESET.UPPERCUT.antiAirDamage;
                        // Passive (UPPERCUT) hits Active (JUMP)
                        overrideResult = resolveHit(passivePlayer, passiveName, activePlayer, damage, MOVESET.UPPERCUT.onHitAdvantage, `UPPERCUT COUNTERS ${activeName}'s JUMP for Anti-Air damage (${damage})!`);
                    } else if (passivePlayer.move === 'AERIAL_KICK') {
                        // AERIAL_KICK is also an air-to-air, but let's assume if they jump it's an air-to-air hit for max damage
                        const damage = MOVESET.AERIAL_KICK.maxDamage;
                        overrideResult = resolveHit(passivePlayer, passiveName, activePlayer, damage, MOVESET.AERIAL_KICK.onHitAdvantage, `AERIAL KICK COUNTERS ${activeName}'s JUMP for HUGE damage (${damage})!`);
                    }
                }
                
                if (overrideResult) {
                    message += overrideResult;
                } else {
                    // --- Standard Sequential Resolution ---
                    
                    // Determine roles for sequential execution (Faster move always resolves first)
                    att = activePlayer; def = passivePlayer;
                    attName = activeName; defName = passiveName;
                    
                    // B. Resolve Interaction
                    message += resolveSequentialInteraction(att, attName, def, defName);

                    // C. Apply penalty to the *other* player only if the interaction was non-decisive
                    const interactionWasDecisive = message.includes("INTERRUPTS") || message.includes("BLOCKED") || message.includes("GRABS") || message.includes("PARRY's") || message.includes("FEINTS");

                    if (!interactionWasDecisive && !['BLOCK', 'DASH_FWD', 'DASH_BACK', 'JUMP', 'FEINT', 'PARRY'].includes(passivePlayer.move)) {
                        message += " | " + applyPenalty(passivePlayer, passiveName, passivePlayer.move, passiveData.onWhiffPenalty, `${passivePlayer.move} resolves late.`);
                    }
                }
                
            } else {
                // Priorities are equal (CLASH or Standoff)
                
                // --- Equal Priority Parry/Feint Fail Check ---
                const p1ParryFails = P1.move === 'PARRY' && !ATTACK_MOVES.includes(P2.move);
                const p2ParryFails = P2.move === 'PARRY' && !ATTACK_MOVES.includes(P1.move);

                // Check for FEINT/PARRY clash vs non-attack/low priority
                if (P1.move === 'FEINT' && P2.move === 'FEINT') {
                    message += `Double FEINT! Standoff. Both gain 5 Meter.`;
                    P1.meter = Math.min(MAX_METER, P1.meter + 5);
                    P2.meter = Math.min(MAX_METER, P2.meter + 5);
                } else if (p1ParryFails) {
                    P1.isSkippingTurn = 1;
                    P1.meter = Math.max(0, P1.meter + MOVESET.PARRY.onWhiffPenalty);
                    message += `<span class="text-neon-red">P1's PARRY misses P2's ${P2.move}! P1 loses next turn.</span>`;
                    // Execute P2's move
                    if (P2.move !== 'PARRY' && P2.move !== 'FEINT') {
                        message += " | " + applyPenalty(P2, 'P2', P2.move, p2FinalData.onHitAdvantage, `${P2.move} executes successfully.`);
                    }
                } else if (p2ParryFails) {
                    P2.isSkippingTurn = 1;
                    P2.meter = Math.max(0, P2.meter + MOVESET.PARRY.onWhiffPenalty);
                    message += `<span class="text-neon-green">P2's PARRY misses P1's ${P1.move}! P2 loses next turn.</span>`;
                    // Execute P1's move
                    if (P1.move !== 'PARRY' && P1.move !== 'FEINT') {
                        message += " | " + applyPenalty(P1, 'P1', P1.move, p1FinalData.onHitAdvantage, `${P1.move} executes successfully.`);
                    }
                } else {
                    // Normal P:3 vs P:3 clash (e.g. KICK vs THROW or KICK vs AERIAL_KICK)
                    const bothAttacks = ATTACK_MOVES.includes(P1.move) && ATTACK_MOVES.includes(P2.move);
                    const bothParry = P1.move === 'PARRY' && P2.move === 'PARRY';

                    if (bothAttacks) {
                        // Attack vs Attack: CLASH
                        const p1Dmg = p1FinalData.damage / 2;
                        const p2Dmg = p2FinalData.damage / 2;

                        P1.hp = Math.max(0, P1.hp - p2Dmg);
                        P2.hp = Math.max(0, P2.hp - p1Dmg);
                        P1.meter = Math.min(MAX_METER, P1.meter + 5);
                        P2.meter = Math.min(MAX_METER, P2.meter + 5);
                        message += `CLASH! Both attacks connect! P1 takes ${p2Dmg} damage, P2 takes ${p1Dmg} damage.`;
                    } else if (bothParry) {
                        message += `Double PARRY! STALEMATE. Both gain 5 Meter.`;
                        P1.meter = Math.min(MAX_METER, P1.meter + 5);
                        P2.meter = Math.min(MAX_METER, P2.meter + 5);
                    } else {
                        // Standoff/Defense vs Defense
                        message += `${P1.move} vs ${P2.move}. Standoff. Both gain 5 Meter.`;
                        P1.meter = Math.min(MAX_METER, P1.meter + 5);
                        P2.meter = Math.min(MAX_METER, P2.meter + 5);
                    }
                }
            }
            
            // Use innerHTML to allow the spans for move names to render colors
            statusMessage.innerHTML = message.trim();

            function resetTurnState() {
                // Reset commitment flags, moves, and airborne status
                P1.move = null;
                P2.move = null;
                P1.isCommitted = false;
                P2.isCommitted = false;
                
                // P1/P2 are only airborne for the duration of the turn, reset status
                if (P1.isAirborne && P1.move !== 'JUMP') P1.isAirborne = false; 
                if (P2.isAirborne && P2.move !== 'JUMP') P2.isAirborne = false;

                // Call updateUI to transition back to the selection screen message
                updateUI();
            }

            // --- Delay State Reset to allow player to read the result message ---
            setTimeout(resetTurnState, 1800); 
        }

        // Handle move selection and commitment
        function handleMoveSelection(e) {
            const btn = e.target.closest('.move-button');
            if (!btn) return;

            const player = btn.dataset.player;
            const move = btn.dataset.move;
            const playerState = player === 'p1' ? P1 : P2;
            const playerChar = player === 'p1' ? p1Char : p2Char;
            const colorClass = player === 'p1' ? 'p1-selected' : 'p2-selected';

            // Check if player is stunned/skipping or already committed
            if (playerState.isSkippingTurn > 0) return;
            if (playerState.isCommitted) return;

            // Clear previous visual selection and set new selection
            $$(`.move-button[data-player="${player}"]`).forEach(b => {
                b.classList.remove('selected', colorClass);
            });

            // Set move and commit
            playerState.move = move;
            btn.classList.add('selected', colorClass);
            playerState.isCommitted = true;
            
            // Visual confirmation flash
            playerChar.classList.add('flash');
            setTimeout(() => {
                playerChar.classList.remove('flash');
            }, 100);
            
            updateUI();
        }

        function isGameOver() {
            return P1.hp <= 0 || P2.hp <= 0;
        }

        function endGame() {
            let winner = '';
            if (P1.hp <= 0 && P2.hp <= 0) {
                winner = "DOUBLE K.O.! It's a tie!";
            } else if (P1.hp <= 0) {
                winner = "PLAYER 2 WINS!";
            } else if (P2.hp <= 0) {
                winner = "PLAYER 1 WINS!";
            }
            
            winnerMessage.textContent = winner;
            gameOverModal.classList.remove('hidden');
        }

        function resetGame() {
            // Reset to default state and ensure airborne is false
            P1 = { hp: 100, meter: 0, move: null, pos: 1, isAirborne: false, isCommitted: false, isSkippingTurn: 0 };
            P2 = { hp: 100, meter: 0, move: null, pos: 9, isAirborne: false, isCommitted: false, isSkippingTurn: 0 };

            gameOverModal.classList.add('hidden');
            statusMessage.textContent = 'SELECT YOUR MOVES & THE TURN WILL EXECUTE!';

            // Reset buttons and UI
            $$('.move-button').forEach(btn => {
                btn.classList.remove('selected', 'p1-selected', 'p2-selected');
                btn.removeAttribute('disabled');
            });
            
            updateUI();
        }

        // Event Listeners
        window.onload = function() {
            // Attach move selection listener (delegated)
            $('#move-selection').addEventListener('click', handleMoveSelection);

            // Attach restart button listener
            $('#restart-button').addEventListener('click', resetGame);
            
            // Initial UI update
            resetGame();
        };

    </script>
</body>
</html>
